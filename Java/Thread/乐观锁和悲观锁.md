## 1.什么是乐观锁和悲观锁

> 乐观锁，根据名字来看，就是干什么都很乐观，什么事情都是往好的方向去想，天塌下来还有高个子的顶着。
>
> 悲观锁，不论何时都很悲观，什么事情都是往坏的方向去想。天塌下来怎么办啊？愁死我了。

**悲观锁**

总是假设最坏的情况，不管在任何情况下都对代码进行加锁，Java中的synchronized和ReetranLock等独占锁都是悲观锁的实现。

**乐观锁**

总是假设最好的情况。每次拿数据都认为别人不会修改，但是在更新的时候会判断一下在此期间有没有人进行过修改，可以使用版本号加CAS算法实现。



**使用场景**

* 乐观锁：多读场景
* 悲观锁：多写场景



## 2.乐观锁的两种实现方式

### 2.1版本号机制

思考了一下，其实很简单，就是给共享的数据加一个version，当线程A读取到该共享数据的时候，同时也读取到了version.如果要写回该共享数据的时候，将当前version与共享变量的version进行对比，如果一样，则进行更新，如果不一样，则重新进行尝试。

### 2.2CAS算法

CAS是一种无锁算法，即Compare And Swap. 其中涉及到了三个变量：

* 内存值V
* 旧值A
* 替换值B

也就是说当一个线程要更新V中的值时候，如果V的值和A相等，我才将其替换成B，否则不会执行任何操作。一般情况下就是一个**自旋操作**，即不断重试。

## 3.乐观锁的缺点

### 3.1ABA问题

ABA问题，很好理解，就是你不知道现在的A是没人改过，还是中间有人将它改成了B,然后又改回了A。怎么解决？加上版本号进行判断，或者时间戳。

### 3.2循环时间长开销大

自旋操作如果长时间不成功，会给CPU带来巨大的消耗。

### 3.3只能保证一个共享变量的原子操作

CAS只对单个共享变量有效，对多个共享变量无效。

## 

### 	

